# GTE Perps & Launchpad

## Findings Summary

| ID | Title | Duplicates |
| - | - | - |
| [H-01](#launchtoken-rewards-accrual-may-not-end-as-intended-due-to-incorrect-check) | LaunchToken rewards accrual may not end as intended due to incorrect check | 71 |
| [M-01](#precision-loss-can-occur-in-staking-rewards-flow-for-quote-tokens-with-low-decimals) | Precision loss can occur in staking rewards flow for quote tokens with low decimals | 13 |


## LaunchToken rewards accrual may not end as intended due to incorrect check

## Vulnerability Detail

```solidity
function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {
    if (!unlocked && from != launchpad && to != launchpad && to != gteRouter) {
        revert TransfersDisabledWhileBonding();
    }

    if (!unlocked) {
        if (from != launchpad && to != launchpad && to != gteRouter) revert TransfersDisabledWhileBonding();

>       if (from == launchpad && to != launchpad) _increaseFeeShares(to, amount);
        else if (to != launchpad && to != gteRouter) revert TransfersDisabledWhileBonding();
    }

>   if (from != launchpad) _decreaseFeeShares(from, amount);
}
    
function _increaseFeeShares(address account, uint256 amount) internal {
    if (amount == 0 || account == address(0)) return;

    emit FeeShareIncreased(account, amount, _incEventNonce());

    unchecked {
        totalFeeShare += amount;
        bondingShare[account] += amount;
    }

    ILaunchpad(launchpad).increaseStake(account, uint96(amount));
}
    
function _decreaseFeeShares(address account, uint256 amount) internal {
    uint256 share = bondingShare[account];
    if (share == 0 || account == address(0)) return;

    amount = amount > share ? share : amount;

    emit FeeShareDecreased(account, amount, _incEventNonce());

    unchecked {
        totalFeeShare -= amount;
        bondingShare[account] -= amount;
    }

    if (totalFeeShare == 0 && !unlocked) _endRewards();
    // @audit unclear if this is the correct trigger

    ILaunchpad(launchpad).decreaseStake(account, uint96(amount));
}
```

`LaunchToken::_beforeTransfer()` hook contains logic that will call `_increaseFeeShares()` and `_decreaseFeeShares()`.

`LaunchToken::_increaseFeeShares()` and `LaunchToken::_decreaseFeeShares()` update the user’s share accounting for rewards calculations. 

When a `LaunchToken` is first created, 80% of the bonding supply is locked on a curve and will be sold from it.

When a `LaunchToken` is bought off the curve, `LaunchToken::_increaseFeeShares()` will be called, which will increase `totalFeeShares` by the amount that is purchased.

`LaunchToken` cannot be transferred during the bonding phase.

Therefore, `LaunchToken::_decreaseFeeShares()` will only be called if a user sells back the `LaunchToken` to `Launchpad` or after graduation is triggered when transfers are opened for users.

```solidity
function buy(BuyData calldata buyData)
    external
    nonReentrant
    onlyBondingActive(buyData.token)
    onlySenderOrOperator(buyData.account, SpotOperatorRoles.LAUNCHPAD_FILL)
    returns (uint256 amountOutBaseActual, uint256 amountInQuote)
{
    // SNIP

    // If graduated, handle AMM setup and remaining swap
    if (!data.active) {
>       (amountOutBaseActual, amountInQuote) = _graduate(buyData, pair, data, amountOutBaseActual, amountInQuote);
    }
}
    
function _graduate(
    BuyData calldata buyData,
    IUniswapV2Pair pair,
    LaunchData memory data,
    uint256 amountOutBaseActual,
    uint256 amountInQuote
) internal returns (uint256 finalAmountOutBaseActual, uint256 finalAmountInQuote) {
>   LaunchToken(buyData.token).unlock();
    _launches[buyData.token].active = false;
    emit BondingLocked(buyData.token, pair, LaunchpadEventNonce.inc());

    uint256 additionalQuote = _createPairAndSwapRemaining({
        token: buyData.token,
        pair: pair,
        data: data,
        remainingBase: buyData.amountOutBase - amountOutBaseActual,
        remainingQuote: buyData.maxAmountInQuote - amountInQuote,
        recipient: buyData.recipient
    });

    finalAmountInQuote = amountInQuote + additionalQuote;
    finalAmountOutBaseActual = additionalQuote > 0 ? buyData.amountOutBase : amountOutBaseActual;
}
    
function unlock() external onlyLaunchpad {
>   unlocked = true;
    emit TransfersUnlocked(block.timestamp, _incEventNonce());
}
```

The graduation process is triggered when the entire bonding supply is purchased via `Launchpad::buy()` - `unlocked` will be toggled to true in this process.

```solidity
function _decreaseFeeShares(address account, uint256 amount) internal {
    uint256 share = bondingShare[account];
    if (share == 0 || account == address(0)) return;

    amount = amount > share ? share : amount;

    emit FeeShareDecreased(account, amount, _incEventNonce());

    unchecked {
        totalFeeShare -= amount;
        bondingShare[account] -= amount;
    }

>   if (totalFeeShare == 0 && !unlocked) _endRewards();

    ILaunchpad(launchpad).decreaseStake(account, uint96(amount));
}

/// @dev Hook to end rewards program for this base token if no more pre-bonding shares exist
function _endRewards() internal {
    ILaunchpad(launchpad).endRewards();

    emit FeeShareConcluded(block.timestamp, _incEventNonce());
}
```

In `LaunchToken::_decreaseFeeShares()`, `LaunchToken::_endRewards()` is supposed to be called when `totalFeeShare = 0` and `unlocked = false`.

`LaunchToken::_endRewards()` will trigger the following flow:

`LaunchToken::_endRewards()` → `Launchpad::endRewards()` → `Distributor::endRewards()` → `Pair::endRewardsAccrual()` 

`Pair::endRewardsAccrual()` will stop forwarding swap fees to `Distributor`. 

Currently, the only time `totalFeeShare = 0` and `unlocked = false` can occur is if the first purchaser of a `LaunchToken` sold back their tokens to the `Launchpad`. 

However, at that point, the pair may not have been created and the transaction will revert.

`_endRewards()` is intended to get called later in the `LaunchToken` lifecycle when all the original `LaunchToken` purchasers have ‘sold’ their shares. 

Since `unlocked` will be toggled to true after graduation occurs, `_endRewards()` will never execute due to the check.

1. The trigger for `_endRewards()` is faulty and rewards may not conclude as intended due to `unlocked` check.
2. Users also have no incentive to end rewards accrual - The last few share holders can earn fees forever after majority of the share holders have exited the system.

### PoC

Set up: Copy and paste the code below into `PoCLaunchpad.t.sol`

Run with the following command: `forge test --match-contract PoCLaunchpad9 --match-test test_submissionValidity -vv --via-ir`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {LaunchpadTestBase} from "./LaunchpadTestBase.sol";
import {LaunchToken} from "contracts/launchpad/LaunchToken.sol";
import {ILaunchpad} from "contracts/launchpad/interfaces/ILaunchpad.sol";
import {Distributor} from "contracts/launchpad/Distributor.sol";

import {IUniswapV2Pair} from "contracts/launchpad/interfaces/IUniswapV2Pair.sol";
import {IGTELaunchpadV2Pair} from "contracts/launchpad/uniswap/interfaces/IGTELaunchpadV2Pair.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";
import {console} from "forge-std/console.sol";

import {IOperatorPanel} from "contracts/utils/interfaces/IOperatorPanel.sol";
import {SpotOperatorRoles} from "contracts/utils/OperatorPanel.sol";

contract PoCLaunchpad9 is LaunchpadTestBase {
    /**
     * PoC can utilize the following variables to access the relevant contracts:
     * - factory: ERC1967Factory.sol 
     * - launchpad: Launchpad.sol
     * - distributor: Distributor.sol
     * - curve: SimpleBondingCurve.sol
     * - launchpadLPVault: LaunchpadLPVault.sol
     * - quoteToken: Quote token used in Launchpad system
     * - uniV2Router: Uniswap V2 Router used in Launchpad system
     */
    
    function test_submissionValidity() external { 
        address user1 = address(0x11111);

        uint256 bondingSupply = launchpad.currentBondingCurve().bondingSupply(token);
        uint256 quoteTotal = curve.quoteQuoteForBase(token, bondingSupply, true);

        quoteToken.mint(user1, quoteTotal);

        vm.startPrank(user1);
        quoteToken.approve(address(launchpad), quoteTotal);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: user1,
                token: token,
                recipient: user1,
                amountOutBase: bondingSupply,
                maxAmountInQuote: quoteTotal
            })
        );

        // @audit-info (totalFeeShare == 0 && !unlocked = true) is not a reachable state 
        uint256 amountInBase = LaunchToken(token).balanceOf(user1);
        
        vm.expectRevert();
        launchpad.sell(
            user1,  // account
            token,  // token
            user1,  // recipient
            amountInBase, // amountInBase
            0 // minAmountOutQuote
        );
        vm.stopPrank();
    }

    function test_submissionValidity1() external { 
        address user1 = address(0x11111);
        address user2 = address(0x2222);

        uint256 bondingSupply = launchpad.currentBondingCurve().bondingSupply(token);
        uint256 quoteTotal = curve.quoteQuoteForBase(token, bondingSupply, true);

        quoteToken.mint(user1, quoteTotal);
        
        // @audit-info user1 purchases entire bonding supply
        vm.startPrank(user1);
        quoteToken.approve(address(launchpad), quoteTotal);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: user1,
                token: token,
                recipient: user1,
                amountOutBase: bondingSupply,
                maxAmountInQuote: quoteTotal
            })
        ); 
        
        // @audit-info graduation sanity check
        bool unlocked = LaunchToken(token).unlocked();
        assert(unlocked);

        // @audit-info totalFeeShare = bonding supply
        uint256 totalFeeShareBefore = LaunchToken(token).totalFeeShare();
        assert(totalFeeShareBefore != 0);
        assert(totalFeeShareBefore == bondingSupply);

        // @audit-info user1 transfers LaunchToken balance, totalFeeShare = 0
        uint256 user1Balance = LaunchToken(token).balanceOf(user1);
        LaunchToken(token).transfer(user2, user1Balance);

        uint256 totalFeeShareAfter = LaunchToken(token).totalFeeShare();
        assert(totalFeeShareAfter == 0);

        // @audit-info condition will never pass due to !unlocked condition
        assert((totalFeeShareAfter == 0 && !unlocked) == false);
        vm.stopPrank();
    }
}
```

## Impact

`LaunchToken::_endRewards()` may not trigger as intended / Last few users can prevent trigger of `LaunchToken::_endRewards()`

## Recommendation

- Correct the condition for `unlocked`
- Consider replacing the `totalFeeShare` condition with a time delay, which triggers `_endRewards()` automatically after graduation

```solidity
function _decreaseFeeShares(address account, uint256 amount) internal {
    uint256 share = bondingShare[account];
    if (share == 0 || account == address(0)) return;

    amount = amount > share ? share : amount;

    emit FeeShareDecreased(account, amount, _incEventNonce());

    unchecked {
        totalFeeShare -= amount;
        bondingShare[account] -= amount;
    }

-   if (totalFeeShare == 0 && !unlocked) _endRewards();
+   if ((block.timestamp >= graduationTimestamp + DELAY) && unlocked) _endRewards();

    ILaunchpad(launchpad).decreaseStake(account, uint96(amount));
}
```

## Precision loss can occur in staking rewards flow for quote tokens with low decimals

## Vulnerability Detail

`Distributor` is tightly integrated with the `RewardsTracker`, which manages user shares and handles rewards calculations.

Rewards can be manually added via `Distributor::addRewards()` or will be generated via swap fees from the associated `GTELaunchpadV2Pair`.

For each pair, there are two reward tokens - base rewards (launchToken) and quote rewards (quoteToken). 

Reward amounts will be dependent upon the user’s shares / total shares ratio. 

```solidity
// RewardsTracker.sol
function stake(RewardPoolData storage self, address user, uint96 newShares)
    internal
    returns (uint256 baseAmount, uint256 quoteAmount)
{
    if (newShares == 0) revert ZeroShareStake();

    (uint256 accBaseRewardsPerShare, uint256 accQuoteRewardsPerShare) = self.update();

    UserRewardData storage userData = self.userRewards[user];

    uint256 existingShares = uint96(userData.shares);

    // Calculate pending rewards before updating shares
    if (existingShares > 0) {
        baseAmount = totalAccRewards(existingShares, accBaseRewardsPerShare) - userData.baseRewardDebt;
        quoteAmount = totalAccRewards(existingShares, accQuoteRewardsPerShare) - userData.quoteRewardDebt;
    }

    // Update user shares
    userData.shares += newShares;
>   self.totalShares += newShares;

    // Update reward debts
    userData.baseRewardDebt = uint96(totalAccRewards(existingShares + newShares, accBaseRewardsPerShare));
    userData.quoteRewardDebt = uint96(totalAccRewards(existingShares + newShares, accQuoteRewardsPerShare));
}
```

`totalShares` is incremented in `RewardsTracker::stake()`, which is triggered in the following flow:

`Launchpad::buy()` → `LaunchToken::_beforeTokenTransfer()` → `LaunchToken::_increaseFeeShares()` → `Launchpad::increaseStake()` → `Distributor::increaseStake()` → `RewardsTracker::stake()`

```solidity
// LaunchToken.sol
function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {
    if (!unlocked && from != launchpad && to != launchpad && to != gteRouter) {
        revert TransfersDisabledWhileBonding();
    }

    if (!unlocked) {
        if (from != launchpad && to != launchpad && to != gteRouter) revert TransfersDisabledWhileBonding();

>       if (from == launchpad && to != launchpad) _increaseFeeShares(to, amount);
        else if (to != launchpad && to != gteRouter) revert TransfersDisabledWhileBonding();
    }

    if (from != launchpad) _decreaseFeeShares(from, amount);
}

function _increaseFeeShares(address account, uint256 amount) internal {
    if (amount == 0 || account == address(0)) return;

    emit FeeShareIncreased(account, amount, _incEventNonce());

    unchecked {
        totalFeeShare += amount;
        bondingShare[account] += amount;
    }

>   ILaunchpad(launchpad).increaseStake(account, uint96(amount));
}
```

When `RewardsTracker::stake()` is called, the amount that is used to increment `totalShares` and `userShares` will be the `LaunchToken` amount which is ‘purchased’ then transferred to the buyer. 

Since `LaunchToken` is in `18` decimals, `totalShares` will also be in `18` decimals.

```solidity
// Distributor.sol
function addRewards(address token0, address token1, uint128 amount0, uint128 amount1) external {
    (address launchAsset, address quoteAsset, uint128 launchAssetAmount, uint128 quoteAssetAmount) =
        (token0, token1, amount0, amount1);
    RewardPoolData storage rs = RewardsTrackerStorage.getRewardPool(token0);

    if (rs.quoteAsset == address(0)) {
        rs = RewardsTrackerStorage.getRewardPool(token1);

        if (rs.quoteAsset == address(0)) revert RewardsDoNotExist();

        (launchAsset, quoteAsset, launchAssetAmount, quoteAssetAmount) = (token1, token0, amount1, amount0);
    }

    if (rs.totalShares == 0) revert NoSharesToIncentivize();

    if (launchAssetAmount > 0) {
>       rs.addBaseRewards(launchAsset, launchAssetAmount); // rewards are added in token decimals
        _increaseTotalPending(launchAsset, launchAssetAmount);
        launchAsset.safeTransferFrom(msg.sender, address(this), uint256(launchAssetAmount));
    }

    if (quoteAssetAmount > 0) {
>       rs.addQuoteRewards(launchAsset, quoteAsset, quoteAssetAmount);
        _increaseTotalPending(quoteAsset, quoteAssetAmount);
        quoteAsset.safeTransferFrom(msg.sender, address(this), uint256(quoteAssetAmount));
    }
}
    
// RewardsTracker.sol
function addBaseRewards(RewardPoolData storage self, address baseAsset, uint128 amount) internal {
>   self.pendingBaseRewards += amount;
    emit BaseRewardsAdded(baseAsset, amount);
}

function addQuoteRewards(RewardPoolData storage self, address baseAsset, address quoteAsset, uint128 amount)
    internal
{
>   self.pendingQuoteRewards += amount;
    emit QuoteRewardsAdded(baseAsset, quoteAsset, amount);
}    
```

However, the rewards that are added via `Distributor::addRewards()` will be stored in token’s decimals. 

```solidity
// RewardsTracker.sol
uint128 public constant PRECISION_FACTOR = 1e12;

function getAccRewardsPerShare(RewardPoolData storage self)
    internal
    view
    returns (uint256 accBaseRewardsPerShare, uint256 accQuoteRewardsPerShare)
{
    uint96 totalShares = self.totalShares;
    if (totalShares == 0) return (self.accBaseRewardPerShare, self.accQuoteRewardPerShare);

    accBaseRewardsPerShare = self.accBaseRewardPerShare;
    accQuoteRewardsPerShare = self.accQuoteRewardPerShare;

>   if (self.pendingBaseRewards > 0) {
>       accBaseRewardsPerShare += ((self.pendingBaseRewards * PRECISION_FACTOR) / uint128(totalShares));
>   }

>   if (self.pendingQuoteRewards > 0) {
>       accQuoteRewardsPerShare += ((self.pendingQuoteRewards * PRECISION_FACTOR) / uint128(totalShares));
>   }
    // @audit-info both pendingBaseRewards and pendingQuoteRewards must be in shares decimals for precision loss to be minimized
}
```

`RewardsTracker::getAccRewardsPerShare()` is used to calculate the base rewards per share and quote rewards per share.

`accBaseRewardsPerShare` and `accQuoteRewardsPerShare` are expected to be in `12` decimal precision.

If quoteToken’s decimals are not equal to 18, then `accQuoteRewardsPerShare` will deviate from the expected precision.

That is, if `quoteToken.decimals() > 18` or `quoteToken.decimals() < 18` , the calculation will result in the incorrect precision.

If a token with low decimal precision, such as `USDC` (6) or `USDT` (6), is used as the quoteToken, the calculation for `accQuoteRewardsPerShare` may truncate to 0, due to precision loss. 

This will result in loss of fees for users, who will receive 0 quote rewards, and permanently locked quote tokens in `Distributor`, which cannot be rescued by the admin.

### PoC

1. Copy and paste the code below into `LaunchpadTestBase5.sol`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Distributor} from "contracts/launchpad/Distributor.sol";
import {Launchpad} from "contracts/launchpad/Launchpad.sol";
import {ILaunchpad} from "contracts/launchpad/interfaces/ILaunchpad.sol";
import {SimpleBondingCurve} from "contracts/launchpad/BondingCurves/SimpleBondingCurve.sol";
import {IBondingCurveMinimal} from "contracts/launchpad/BondingCurves/IBondingCurveMinimal.sol";
import {LaunchToken} from "contracts/launchpad/LaunchToken.sol";
import {LaunchpadLPVault} from "contracts/launchpad/LaunchpadLPVault.sol";
import {IDistributor} from "contracts/launchpad/interfaces/IDistributor.sol";

import {ERC1967Factory} from "@solady/utils/ERC1967Factory.sol";

import {ERC20Harness} from "../harnesses/ERC20Harness.sol";

import {MockUniV2Router} from "../mocks/MockUniV2Router.sol";

import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {ICLOBManager} from "contracts/clob/ICLOBManager.sol";
import {IOperatorPanel} from "contracts/utils/interfaces/IOperatorPanel.sol";

import {UniV2Bytecode} from "../launchpad/integration/UniV2Bytecode.t.sol";

import {GTELaunchpadV2PairFactory} from "contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol";

import "forge-std/Test.sol";

import {ERC20} from "@solady/tokens/ERC20.sol";

// Implements the LaunchpadTest setup
contract LaunchpadTestBase5 is Test {
    using FixedPointMathLib for uint256;

    ERC1967Factory factory;
    Launchpad launchpad;
    address distributor;
    IBondingCurveMinimal curve;
    LaunchpadLPVault launchpadLPVault;

    //ERC20Harness quoteToken;
    TestUSDC usdc;
    MockUniV2Router uniV2Router;

    address owner = makeAddr("owner");
    address user = makeAddr("user");
    address dev = makeAddr("dev");

    uint256 constant MIN_BASE_AMOUNT = 100_000_000;

    address token; // @audit-info launchToken

    uint256 BONDING_SUPPLY;
    uint256 TOTAL_SUPPLY;

    GTELaunchpadV2PairFactory v2Factory; 

    function setUp() public virtual {
        usdc = new TestUSDC();
        
        factory = new ERC1967Factory();

        bytes32 launchpadSalt = bytes32(abi.encode("GTE.V1.TESTNET.LAUNCHPAD", owner));

        launchpad = Launchpad(factory.predictDeterministicAddress(launchpadSalt));

        distributor = address(new Distributor());
        Distributor(distributor).initialize(address(launchpad));

        // @audit-info deploy GTELaunchpadV2PairFactory
        v2Factory = new GTELaunchpadV2PairFactory(address(this), address(launchpad), address(launchpad), address(distributor));
        uniV2Router = new MockUniV2Router(address(v2Factory));

        address c_logic = address(new SimpleBondingCurve(address(launchpad)));
        address v_logic = address(new LaunchpadLPVault());

        curve = SimpleBondingCurve(factory.deploy(address(c_logic), owner));
        launchpadLPVault = LaunchpadLPVault(factory.deploy(address(v_logic), owner));
 
        address clobManager = makeAddr("clob manager");
        address operatorAddr = makeAddr("operator");
        vm.mockCall(
            operatorAddr,
            abi.encodeWithSelector(IOperatorPanel.getOperatorRoleApprovals.selector, user, address(0)),
            abi.encode(0)
        );

        address l_logic =
            address(new Launchpad(address(uniV2Router), address(0), clobManager, operatorAddr, distributor));

        vm.prank(owner);
        Launchpad(
            factory.deployDeterministicAndCall({
                implementation: l_logic,
                admin: owner,
                salt: launchpadSalt,
                data: abi.encodeCall(
                    Launchpad.initialize,
                    (
                        owner,
                        address(usdc),
                        address(curve),
                        address(launchpadLPVault),
                        abi.encode(200_000_000 ether, 100_000e6)
                    )
                )
            })
        );

        token = _launchToken();

        BONDING_SUPPLY = curve.bondingSupply(token);
        TOTAL_SUPPLY = curve.totalSupply(token);
    }

    function _launchToken() internal returns (address) {
        uint256 fee = launchpad.launchFee();
        deal(dev, 30 ether);

        vm.prank(dev);
        return launchpad.launch{value: fee}("TestToken", "TST", "https://testtoken.com");
    }
}

contract TestUSDC is ERC20 {
    function name() public pure override returns (string memory) {
        return "USD Coin";
    }

    function symbol() public pure override returns (string memory) {
        return "USDC";
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function decimals() public pure override returns (uint8) {
        return 6;
    }
}
```

1. Copy and paste the code below into `PoCLaunchpad5.t.sol`
    
    Run with the following command: `forge test --match-contract PoCLaunchpad5 --match-test test_submissionValidity -vv --via-ir`
    

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {LaunchpadTestBase5} from "./LaunchpadTestBase5.sol";
import {LaunchToken} from "contracts/launchpad/LaunchToken.sol";
import {ILaunchpad} from "contracts/launchpad/interfaces/ILaunchpad.sol";
import {Distributor} from "contracts/launchpad/Distributor.sol";

import {IUniswapV2Pair} from "contracts/launchpad/interfaces/IUniswapV2Pair.sol";
import {IGTELaunchpadV2Pair} from "contracts/launchpad/uniswap/interfaces/IGTELaunchpadV2Pair.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";
import {console} from "forge-std/console.sol";

contract PoCLaunchpad5 is LaunchpadTestBase5 {
    /**
     * PoC can utilize the following variables to access the relevant contracts:
     * - factory: ERC1967Factory.sol 
     * - launchpad: Launchpad.sol
     * - distributor: Distributor.sol
     * - curve: SimpleBondingCurve.sol
     * - launchpadLPVault: LaunchpadLPVault.sol
     * - quoteToken: Quote token used in Launchpad system
     * - uniV2Router: Uniswap V2 Router used in Launchpad system
     */
    function test_submissionValidity() external { // #5
        address user1 = address(0x11111);
        address user2 = address(0x22222);
        address user3 = address(0x33333);

        // @audit-info several users will buy out the entire launchToken supply to trigger graduation
        uint256 end = BONDING_SUPPLY;
        uint256 quoteTotal = curve.quoteQuoteForBase(token, end, true);

        uint256 user1Base = end * 5 / 100;
        uint256 user1Quote = quoteTotal * 5 / 100;
        usdc.mint(user1, user1Quote);

        vm.startPrank(user1);
        usdc.approve(address(launchpad), user1Quote);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: user1,
                token: token,
                recipient: user1,
                amountOutBase: user1Base,
                maxAmountInQuote: user1Quote
            })
        );
        vm.stopPrank();

        uint256 user2Base = end * 15 / 100;
        uint256 user2Quote = quoteTotal * 30 / 100;
        usdc.mint(user2, user2Quote);

        vm.startPrank(user2);
        usdc.approve(address(launchpad), user2Quote);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: user2,
                token: token,
                recipient: user2,
                amountOutBase: user2Base,
                maxAmountInQuote: user2Quote
            })
        );
        vm.stopPrank();

        uint256 user3Base = end - user2Base - user1Base;
        uint256 user3Quote = curve.quoteQuoteForBase(token, user3Base, true);
        usdc.mint(user3, user3Quote);

        vm.startPrank(user3);
        usdc.approve(address(launchpad), user3Quote);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: user3,
                token: token,
                recipient: user3,
                amountOutBase: user3Base,
                maxAmountInQuote: user3Quote
            })
        );
        vm.stopPrank();

        // @audit-info ensure LaunchToken.unlock() was called - Launchpad::_graduate()
        bool unlocked = LaunchToken(token).unlocked();
        assert(unlocked);

        // @audit-info dev manually adds incentives to Distributor
        uint128 initialBaseRewards = 150e18;
        uint128 initialQuoteRewards = 100e6;

        // fund dev
        usdc.mint(address(dev), 100e6);
        deal(token, address(dev), 150e18);
        
        vm.startPrank(dev);
        usdc.approve(address(distributor), 100e6);
        LaunchToken(token).approve(address(distributor), 150e18);

        Distributor(distributor).addRewards(address(usdc), token, initialQuoteRewards, initialBaseRewards);
        vm.stopPrank();

        RewardPoolDataMemory memory rewardPoolData = Distributor(distributor).getRewardsPoolData(token);
        uint256 totalShares = rewardPoolData.totalShares;
        uint256 pendingBaseRewards = rewardPoolData.pendingBaseRewards;
        uint256 pendingQuoteRewards = rewardPoolData.pendingQuoteRewards;

        console.log("totalShares: %s", totalShares);
        console.log("pendingBaseRewards: %s", pendingBaseRewards);
        console.log("pendingQuoteRewards: %s", pendingQuoteRewards);

        // getAccRewardsPerShare() calculation
        uint256 accBaseRewardsPerShare = pendingBaseRewards * 1e12 / totalShares;
        /* 
           pendingBaseRewards = baseToken decimals (assume 18 decimals)
           PRECISION_FACTOR = 1e12
           totalShares = baseToken decimals (assume 18 decimals)
           
           accBaseRewardsPerShare = 1e18 * 1e12 / 1e18 = 1e12 -> ok
        */

        uint256 accQuoteRewardsPerShare = pendingQuoteRewards * 1e12 / totalShares;
        /*
           pendingQuoteRewards = quoteToken decimals (assume 6 decimals for USDC)
           PRECISION_FACTOR = 1e12
           totalShares = baseToken decimals (assume 18 decimals)

           accQuoteRewardsPerShare = 1e6 * 1e12 / 1e18 = 1 -> precision loss
         */

        // accQuoteRewardsPerShare results in 0 due to precision loss
        assert(accQuoteRewardsPerShare == 0);
        console.log("accBaseRewardsPerShare: %s", accBaseRewardsPerShare);
        console.log("accQuoteRewardsPerShare: %s\n", accQuoteRewardsPerShare);

        // @audit-info all users claim - none receive any quote rewards due to accQuoteRewardsPerShare miscalculation
        vm.prank(user1);
        (uint256 baseReward, uint256 quoteReward) = Distributor(distributor).claimRewards(token);
        console.log("user1 base rewards: %s", baseReward);
        console.log("user1 quote rewards: %s", quoteReward);   

        vm.prank(user2);
        (baseReward, quoteReward) = Distributor(distributor).claimRewards(token);
        console.log("user2 base rewards: %s", baseReward);
        console.log("user2 quote rewards: %s", quoteReward);   

        vm.prank(user3);
        (baseReward, quoteReward) = Distributor(distributor).claimRewards(token);
        console.log("user3 base rewards: %s", baseReward);
        console.log("user3 quote rewards: %s", quoteReward);  

        // @audit-info usdc rewards are permanently stuck in distributor
        uint256 usdcBalance = usdc.balanceOf(distributor);
        assert(usdcBalance == Distributor(distributor).totalPendingRewards(address(usdc)));

        vm.expectRevert();
        Distributor(distributor).skimExcessRewards(address(usdc), usdcBalance);
    }
}
```

```solidity
Ran 1 test for test/c4-poc/PoCLaunchpad5.t.sol:PoCLaunchpad5
[PASS] test_submissionValidity() (gas: 3738819)
Logs:
  totalShares: 800000000000000000000000000
  pendingBaseRewards: 150000000000000000000
  pendingQuoteRewards: 100000000
  accBaseRewardsPerShare: 187500
  accQuoteRewardsPerShare: 0

  user1 base rewards: 7500000000000000000
  user1 quote rewards: 0
  user2 base rewards: 22500000000000000000
  user2 quote rewards: 0
  user3 base rewards: 120000000000000000000
  user3 quote rewards: 0

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.69ms (3.12ms CPU time)
```

## Impact

`quoteToken` rewards are permanently locked in the `distributor` / Loss of fees for users

## Recommendation

Re-factor `RewardsTracker::getAccRewardsPerShare()` to include additional scaling for the `accQuoteRewardsPerShare` calculation.

Re-factor `RewardsTracker::totalAccRewards()` to correctly compute output token decimals.

## Users risk losing rewards when increaseStake() or decreaseStake() is called

## Vulnerability Detail

```solidity
function _distributeAssets(address base, uint256 baseAmount, address quote, uint256 quoteAmount) internal {
    if (baseAmount > 0) {
        _decreaseTotalPending(base, baseAmount);
        base.safeTransfer(msg.sender, baseAmount);
    }

    if (quoteAmount > 0) {
        _decreaseTotalPending(quote, quoteAmount);
        quote.safeTransfer(msg.sender, quoteAmount);
    }
}
```

`Distributor::_distributeAssets()` is a push method used to send rewards to the `msg.sender`.

```solidity
function increaseStake(address launchAsset, address account, uint96 shares)
    external
>   onlyLaunchpad 
    returns (uint256 baseAmount, uint256 quoteAmount)
{
    RewardPoolData storage rs = RewardsTrackerStorage.getRewardPool(launchAsset);

    (baseAmount, quoteAmount) = rs.stake(account, uint96(shares));
>   _distributeAssets(launchAsset, baseAmount, rs.quoteAsset, quoteAmount);
}

function decreaseStake(address launchAsset, address account, uint96 shares)
    external
>   onlyLaunchpad
    returns (uint256 baseAmount, uint256 quoteAmount)
{
    RewardPoolData storage rs = RewardsTrackerStorage.getRewardPool(launchAsset);

    (baseAmount, quoteAmount) = rs.unstake(account, uint96(shares));
>   _distributeAssets(launchAsset, baseAmount, rs.quoteAsset, quoteAmount);
}

// unstake() omitted for brevity
function stake(RewardPoolData storage self, address user, uint96 newShares)
    internal
    returns (uint256 baseAmount, uint256 quoteAmount)
{
    if (newShares == 0) revert ZeroShareStake();

    (uint256 accBaseRewardsPerShare, uint256 accQuoteRewardsPerShare) = self.update();

    UserRewardData storage userData = self.userRewards[user];

    uint256 existingShares = uint96(userData.shares);

    // Calculate pending rewards before updating shares
    if (existingShares > 0) {
>       baseAmount = totalAccRewards(existingShares, accBaseRewardsPerShare) - userData.baseRewardDebt;
>       quoteAmount = totalAccRewards(existingShares, accQuoteRewardsPerShare) - userData.quoteRewardDebt;
    }

    // Update user shares
    userData.shares += newShares;
    self.totalShares += newShares;

    // Update reward debts
>   userData.baseRewardDebt = uint96(totalAccRewards(existingShares + newShares, accBaseRewardsPerShare));
>   userData.quoteRewardDebt = uint96(totalAccRewards(existingShares + newShares, accQuoteRewardsPerShare));
}
```

When `Distributor::increaseStake()` or `Distributor::decreaseStake()` is called the `msg.sender` will be the `Launchpad`.

`baseAmount` and `quoteAmount` that is returned from `stake()` and `unstake()` is the pending base and quote rewards for the user, respectively.

```solidity
// Launchpad.sol
function increaseStake(address account, uint96 shares) external onlyLaunchAsset {
    distributor.increaseStake(msg.sender, account, shares);
}

function decreaseStake(address account, uint96 shares) external onlyLaunchAsset {
    distributor.decreaseStake(msg.sender, account, shares);
}
```

`Launchpad::increaseStake()` and `Launchpad::decreaseStake()` is missing logic to handle the tokens which are sent back as rewards from `Distributor`.

These tokens will be permanently stuck and cannot be recovered from `Launchpad`.

### PoC

- Copy and paste the code below into `PoCLaunchpad6.t.sol`
- Run with the following command: `forge test --match-contract PoCLaunchpad6 --match-test test_submissionValidity -vv --via-ir`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {LaunchpadTestBase} from "./LaunchpadTestBase.sol";
import {LaunchToken} from "contracts/launchpad/LaunchToken.sol";
import {ILaunchpad} from "contracts/launchpad/interfaces/ILaunchpad.sol";
import {Distributor} from "contracts/launchpad/Distributor.sol";

import {IUniswapV2Pair} from "contracts/launchpad/interfaces/IUniswapV2Pair.sol";
import {IGTELaunchpadV2Pair} from "contracts/launchpad/uniswap/interfaces/IGTELaunchpadV2Pair.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";
import {console} from "forge-std/console.sol";

contract PoCLaunchpad6 is LaunchpadTestBase {
    /**
     * PoC can utilize the following variables to access the relevant contracts:
     * - factory: ERC1967Factory.sol 
     * - launchpad: Launchpad.sol
     * - distributor: Distributor.sol
     * - curve: SimpleBondingCurve.sol
     * - launchpadLPVault: LaunchpadLPVault.sol
     * - quoteToken: Quote token used in Launchpad system
     * - uniV2Router: Uniswap V2 Router used in Launchpad system
     */
    
    // 6.1 - Stuck rewards due to incorrect distribution via decreaseStake() 
    function test_submissionValidity() external { 
        address user1 = address(0x11111);
        address user2 = address(0x22222);
        address user3 = address(0x33333);

        // several users will buy out the entire launchToken supply to trigger graduation
        uint256 end = BONDING_SUPPLY;
        uint256 quoteTotal = curve.quoteQuoteForBase(token, end, true);

        uint256 user1Quote = quoteTotal * 5 / 100;
        uint256 user2Quote = quoteTotal * 30 / 100;
        quoteToken.mint(user1, user1Quote);
        quoteToken.mint(user2, user2Quote);

        uint256 user1Base = end * 5 / 100;
        vm.startPrank(user1);
        quoteToken.approve(address(launchpad), user1Quote);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: user1,
                token: token,
                recipient: user1,
                amountOutBase: user1Base,
                maxAmountInQuote: user1Quote
            })
        );
        vm.stopPrank();

        uint256 user2Base = end * 15 / 100;
        vm.startPrank(user2);
        quoteToken.approve(address(launchpad), user2Quote);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: user2,
                token: token,
                recipient: user2,
                amountOutBase: user2Base,
                maxAmountInQuote: user2Quote
            })
        );
        vm.stopPrank();

        uint256 user3Base = end - user2Base - user1Base;
        uint256 user3Quote = curve.quoteQuoteForBase(token, user3Base, true);
        quoteToken.mint(user3, user3Quote);

        vm.startPrank(user3);
        quoteToken.approve(address(launchpad), user3Quote);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: user3,
                token: token,
                recipient: user3,
                amountOutBase: user3Base,
                maxAmountInQuote: user3Quote
            })
        );
        vm.stopPrank();

        // @audit-info check if launchToken.unlock() was called
        bool unlocked = LaunchToken(token).unlocked();
        assert(unlocked);

        // @audit-info dev adds incentives to Distributor
        uint128 initialBaseRewards = 150e18;

        // fund dev
        deal(token, address(dev), 150e18);
        
        vm.startPrank(dev);
        LaunchToken(token).approve(address(distributor), 150e18);

        Distributor(distributor).addRewards(token, address(quoteToken), initialBaseRewards, 0);
        vm.stopPrank();

        // after graduation, launchpad has no balance
        uint256 preLaunchpadBase = LaunchToken(token).balanceOf(address(launchpad)); // launchToken
        assert(preLaunchpadBase == 0);

        // accrued user1 rewards 
        (uint256 pendingBase,) = Distributor(distributor).getPendingRewards(token, user1);
        assert(pendingBase != 0);

        // @audit-info user transfers launchToken's prior to claiming from Distributor
        uint256 user1BaseBalance = LaunchToken(token).balanceOf(user1);
        vm.prank(user1);
        LaunchToken(token).transfer(user2, user1BaseBalance);

        // @audit-info user forfeits any rewards to launchpad
        //     these rewards are permanently stuck in launchpad
        (uint256 pendingBaseAfter,) = Distributor(distributor).getPendingRewards(token, user1);
        assert(pendingBaseAfter == 0);

        uint256 postLaunchpadBase = LaunchToken(token).balanceOf(address(launchpad));
        assert(postLaunchpadBase != 0);

        console.log("Pre-transfer Launchpad LaunchToken Balance: %s", preLaunchpadBase);
        console.log("Pre-transfer user1 Pending Base Rewards: %s", pendingBase);
        console.log("Post-transfer Launchpad LaunchToken Balance: %s", postLaunchpadBase);
        console.log("Post-transfer user1 Pending Base Rewards: %s", pendingBaseAfter);
    }

    // 6.2 - Stuck rewards due to incorrect distribution via increaseStake()
    function test_submissionValidity1() external {
        address user1 = address(0x11111);
        address user2 = address(0x22222);
        address user3 = address(0x33333);

        // user1 purchases launchToken during bonding phase
        uint256 end = BONDING_SUPPLY;
        uint256 quoteTotal = curve.quoteQuoteForBase(token, end, true);
    
        uint256 user1Base = end * 5 / 100;
        uint256 user1Quote = quoteTotal * 5 / 100;
        quoteToken.mint(user1, user1Quote);

        vm.startPrank(user1);
        quoteToken.approve(address(launchpad), user1Quote);
        (, uint256 amountInQuote1) = launchpad.buy(
            ILaunchpad.BuyData({
                account: user1,
                token: token,
                recipient: user1,
                amountOutBase: user1Base,
                maxAmountInQuote: user1Quote
            })
        );
        vm.stopPrank();

        // @audit-info dev adds incentives to distributor
        uint128 initialQuoteRewards = 150e18;
        deal(address(quoteToken), address(dev), 150e18);
        
        vm.startPrank(dev);
        quoteToken.approve(address(distributor), 150e18);

        Distributor(distributor).addRewards(token, address(quoteToken), 0, initialQuoteRewards);
        vm.stopPrank();

        (, uint256 pendingQuote) = Distributor(distributor).getPendingRewards(token, user1);
        assert(pendingQuote != 0);  // rewards are accrued for user1

        // @audit-info user1 makes another purchase 
        uint256 preLaunchpadQuote = quoteToken.balanceOf(address(launchpad));

        uint256 user2Base = end * 15 / 100;
        uint256 user2Quote = quoteTotal * 30 / 100;
        quoteToken.mint(user1, user2Quote);

        vm.startPrank(user1);
        quoteToken.approve(address(launchpad), user2Quote);
        (, uint256 amountInQuote2) = launchpad.buy(
            ILaunchpad.BuyData({
                account: user1,
                token: token,
                recipient: user1,
                amountOutBase: user2Base,
                maxAmountInQuote: user2Quote
            })
        );
        vm.stopPrank();

        (, uint256 pendingQuoteAfter) = Distributor(distributor).getPendingRewards(token, user1);
        assert(pendingQuoteAfter == 0);  // user forfeits all pending rewards to Launchpad

        /* Launchpad Quote Balance Calculation
         *   amountInQuote1 - quote amount of user1 first buy
         *   amountInQuote2 - quote amount of user1 second buy
         *   pendingQuote - amount of user1 pending quote rewards prior to second buy
         */
        uint256 postLaunchpadQuote = quoteToken.balanceOf(address(launchpad));
        uint256 launchTokenTotal = amountInQuote1 + amountInQuote2 + pendingQuote;
        assert(launchTokenTotal == postLaunchpadQuote);
        
        console.log("Pre-transfer Launchpad quoteToken Balance: %s", preLaunchpadQuote);
        console.log("Pre-transfer user1 Pending Quote Rewards: %s", pendingQuote);
        console.log("Post-transfer Launchpad quoteToken Balance: %s", postLaunchpadQuote);
        console.log("Post-transfer user1 Pending Quote Rewards: %s", pendingQuoteAfter);
    }
}
```

```solidity
Ran 2 tests for test/c4-poc/PoCLaunchpad6.t.sol:PoCLaunchpad6
[PASS] test_submissionValidity() (gas: 3505459)
Logs:
  Pre-transfer Launchpad LaunchToken Balance: 0
  Pre-transfer user1 Pending Base Rewards: 7500000000000000000
  Post-transfer Launchpad LaunchToken Balance: 7500000000000000000
  Post-transfer user1 Pending Base Rewards: 0

[PASS] test_submissionValidity1() (gas: 593276)
Logs:
  Pre-transfer Launchpad quoteToken Balance: 416666666666666666
  Pre-transfer user1 Pending Quote Rewards: 150000000000000000000
  Post-transfer Launchpad quoteToken Balance: 151904761904761904761
  Post-transfer user1 Pending Quote Rewards: 0

Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 3.83ms (1.91ms CPU time)

Ran 1 test suite in 165.72ms (3.83ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)
```

## Impact

Permanently stuck funds in `Launchpad` and loss of rewards for users

## Recommendation

```solidity
// Launchpad.sol
function increaseStake(address account, uint96 shares) external onlyLaunchAsset {
-   distributor.increaseStake(msg.sender, account, shares);
+   (uint256 baseAmount, uint256 quoteAmount) = distributor.increaseStake(msg.sender, account, shares);
+   if (baseAmount != 0) {
+        msg.sender.safeTransfer(account, baseAmount);
+   }
+   if (quoteAmount != 0) {
+        address qToken = _launches[msg.sender].quote;
+        qToken.safeTransfer(account, quoteAmount);
+   }
}

function decreaseStake(address account, uint96 shares) external onlyLaunchAsset {
-   distributor.decreaseStake(msg.sender, account, shares);
+   (uint256 baseAmount, uint256 quoteAmount) = distributor.decreaseStake(msg.sender, account, shares);
+   if (baseAmount != 0) {
+        msg.sender.safeTransfer(account, baseAmount);
+   }
+   if (quoteAmount != 0) {
+        address qToken = _launches[msg.sender].quote;
+        qToken.safeTransfer(account, quoteAmount);
+   }
}
```

## Fee collection for GTELaunchpadV2Pair can be bricked

## Vulnerability Detail

```solidity
// Launchpad.sol
function buy(BuyData calldata buyData)
    external
    nonReentrant
    onlyBondingActive(buyData.token)
    onlySenderOrOperator(buyData.account, SpotOperatorRoles.LAUNCHPAD_FILL)
    returns (uint256 amountOutBaseActual, uint256 amountInQuote)
{
    // SNIP

    // If graduated, handle AMM setup and remaining swap
>   if (!data.active) {
>       (amountOutBaseActual, amountInQuote) = _graduate(buyData, pair, data, amountOutBaseActual, amountInQuote);
>   }
}
    
function _graduate(
    BuyData calldata buyData,
    IUniswapV2Pair pair,
    LaunchData memory data,
    uint256 amountOutBaseActual,
    uint256 amountInQuote
) internal returns (uint256 finalAmountOutBaseActual, uint256 finalAmountInQuote) {
    LaunchToken(buyData.token).unlock();
    _launches[buyData.token].active = false;
    emit BondingLocked(buyData.token, pair, LaunchpadEventNonce.inc());

>   uint256 additionalQuote = _createPairAndSwapRemaining({
>       token: buyData.token,
>       pair: pair,
>       data: data,
>       remainingBase: buyData.amountOutBase - amountOutBaseActual,
>       remainingQuote: buyData.maxAmountInQuote - amountInQuote,
>       recipient: buyData.recipient
>   });

    finalAmountInQuote = amountInQuote + additionalQuote;
    finalAmountOutBaseActual = additionalQuote > 0 ? buyData.amountOutBase : amountOutBaseActual;
}
    
function _createPairAndSwapRemaining(
    address token,
    IUniswapV2Pair pair,
    LaunchData memory data,
    uint256 remainingBase,
    uint256 remainingQuote,
    address recipient
) internal returns (uint256 additionalQuoteUsed) {
    /// @todo sr wardens, please flag in your QA report your thoughts on the comments below

>   // Create or get the pair
>   try uniV2Factory.createPair(token, data.quote) returns (address p) {
>       pair = IUniswapV2Pair(p);
>   } catch {
>       // Do nothing, pair exists
>       // @todo its more gas but lets check pair exists and create if it doest.
>       // try catch in solidity is horrible and should be avoided
>   }

    // SNIP - addLiquidity() + swap remaining 
}
```

The `Launchpad` graduation flow is triggered when the entire bonding supply of a `LaunchToken` is purchased.

A new LP pair will be created, if the pair doesn’t exist, then the pair will be seeded with funds and the remaining amount will be swapped.

```solidity
// GTELaunchpadV2PairFactory.sol
function createPair(address tokenA, address tokenB) external returns (address pair) {
    if (tokenA == tokenB) revert("UniswapV2: IDENTICAL_ADDRESSES");
    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    if (token0 == address(0)) revert("UniswapV2: ZERO_ADDRESS");
    if (getPair[token0][token1] != address(0)) revert("UniswapV2: PAIR_EXISTS"); // single check is sufficient
    bytes memory bytecode = type(GTELaunchpadV2Pair).creationCode;

>   (address _launchpadLp, address _launchpadFeeDistributor) =
>       msg.sender == launchpad ? (launchpadLp, launchpadFeeDistributor) : (address(0), address(0));

    bytes32 salt = keccak256(abi.encodePacked(token0, token1, _launchpadLp, _launchpadFeeDistributor));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    }
    IUniswapV2Pair(pair).initialize(token0, token1, _launchpadLp, _launchpadFeeDistributor);
    getPair[token0][token1] = pair;
    getPair[token1][token0] = pair; // populate mapping in the reverse direction
    allPairs.push(pair);
    emit PairCreated(token0, token1, pair, allPairs.length);
}
```

When `GTELaunchpadV2PairFactory::createPair()` is called via the `Launchpad` graduation flow, `_launchpadLp` and `_launchpadFeeDistributor` will be non-zero when initializing the new `GTELaunchpadV2Pair`.

Otherwise, the new `GTELaunchpadV2Pair` will be initialized with both `_launchpadLp` and `_launchpadFeeDistributor` as `address(0)`.

```solidity
// GTELaunchpadV2Pair.sol
function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external lock {
    // SNIP

    {
        // scope for reserve{0,1}Adjusted and launchpadFee{0,1}, avoids stack too deep errors
        uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));

        if (balance0Adjusted.mul(balance1Adjusted) < uint256(_reserve0).mul(_reserve1).mul(1000 ** 2)) {
            revert("UniswapV2: K");
        }

>       (uint112 launchpadFee0, uint112 launchpadFee1) = launchpadFeeDistributor > address(0)
>           && rewardsPoolActive > 0 ? _getLaunchpadFees(amount0In, amount1In) : (uint112(0), uint112(0));

>       _update(balance0, balance1, _reserve0, _reserve1, launchpadFee0, launchpadFee1);
    }

    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
   
// GTELaunchpadV2Pair::_update() -> GTELaunchpadV2Pair::_distributeLaunchpadFees() 
function _distributeLaunchpadFees(uint112 fee0, uint112 fee1) internal {
    if ((fee0 | fee1) > 0) {
        address _token0 = token0;
        address _token1 = token1;
        address distributor = launchpadFeeDistributor;

        // Since only pairs created by the launchpad can accrue fee tracking, the tokens are trusted
        if (fee0 > 0) _safeApprove(_token0, distributor, uint256(fee0));
        if (fee1 > 0) _safeApprove(_token1, distributor, uint256(fee1));

>       IDistributor(distributor).addRewards(_token0, _token1, uint128(fee0), uint128(fee1));

        emit LaunchpadFeesCollected(fee0, fee1);
    }
}
```

If `launchpadFeeDistributor` is never set, both `launchpadFee0` and `launchpadFee1` will always be set to `0` and no fees will accrue for this pair.

The swap fees generated from `GTELaunchpadV2Pair` are intended to be distributed back to users via the `Distributor`.

`GTELaunchpadV2PairFactory::createPair()` is permissionless and can be called by anyone.

If `GTELaunchpadV2PairFactory::createPair()` is called before the graduation flow is triggered for a particular `LaunchToken`, the fee collection will be bricked for the given `GTELaunchpadV2Pair`, resulting in loss of fees for users.

## PoC

1. Copy and paste the code below into `LaunchpadTestBase4.sol`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Distributor} from "contracts/launchpad/Distributor.sol";
import {Launchpad} from "contracts/launchpad/Launchpad.sol";
import {ILaunchpad} from "contracts/launchpad/interfaces/ILaunchpad.sol";
import {SimpleBondingCurve} from "contracts/launchpad/BondingCurves/SimpleBondingCurve.sol";
import {IBondingCurveMinimal} from "contracts/launchpad/BondingCurves/IBondingCurveMinimal.sol";
import {LaunchToken} from "contracts/launchpad/LaunchToken.sol";
import {LaunchpadLPVault} from "contracts/launchpad/LaunchpadLPVault.sol";
import {IDistributor} from "contracts/launchpad/interfaces/IDistributor.sol";

import {ERC1967Factory} from "@solady/utils/ERC1967Factory.sol";

import {ERC20Harness} from "../harnesses/ERC20Harness.sol";

import {MockUniV2Router} from "../mocks/MockUniV2Router.sol";

import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {ICLOBManager} from "contracts/clob/ICLOBManager.sol";
import {IOperatorPanel} from "contracts/utils/interfaces/IOperatorPanel.sol";

import {UniV2Bytecode} from "../launchpad/integration/UniV2Bytecode.t.sol";

import {GTELaunchpadV2PairFactory} from "contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol";

import "forge-std/Test.sol";

// Implements the LaunchpadTest setup
contract LaunchpadTestBase4 is Test {
    using FixedPointMathLib for uint256;

    ERC1967Factory factory;
    Launchpad launchpad;
    address distributor;
    IBondingCurveMinimal curve;
    LaunchpadLPVault launchpadLPVault;

    ERC20Harness quoteToken;
    MockUniV2Router uniV2Router;

    address owner = makeAddr("owner");
    address user = makeAddr("user");
    address dev = makeAddr("dev");

    uint256 constant MIN_BASE_AMOUNT = 100_000_000;

    address token; // @audit-info launchToken

    uint256 BONDING_SUPPLY;
    uint256 TOTAL_SUPPLY;

    GTELaunchpadV2PairFactory v2Factory; // @audit-info factory used for PoC #4

    function setUp() public virtual {
        quoteToken = new ERC20Harness("Quote", "QTE");
        
        factory = new ERC1967Factory();

        bytes32 launchpadSalt = bytes32(abi.encode("GTE.V1.TESTNET.LAUNCHPAD", owner));

        launchpad = Launchpad(factory.predictDeterministicAddress(launchpadSalt));

        distributor = address(new Distributor());
        Distributor(distributor).initialize(address(launchpad));

        // @audit-info deploy GTELaunchpadV2PairFactory
        v2Factory = new GTELaunchpadV2PairFactory(address(this), address(launchpad), address(launchpad), address(distributor));
        uniV2Router = new MockUniV2Router(address(v2Factory));

        address c_logic = address(new SimpleBondingCurve(address(launchpad)));
        address v_logic = address(new LaunchpadLPVault());

        curve = SimpleBondingCurve(factory.deploy(address(c_logic), owner));
        launchpadLPVault = LaunchpadLPVault(factory.deploy(address(v_logic), owner));
 
        address clobManager = makeAddr("clob manager");
        address operatorAddr = makeAddr("operator");
        vm.mockCall(
            operatorAddr,
            abi.encodeWithSelector(IOperatorPanel.getOperatorRoleApprovals.selector, user, address(0)),
            abi.encode(0)
        );

        address l_logic =
            address(new Launchpad(address(uniV2Router), address(0), clobManager, operatorAddr, distributor));

        vm.prank(owner);
        Launchpad(
            factory.deployDeterministicAndCall({
                implementation: l_logic,
                admin: owner,
                salt: launchpadSalt,
                data: abi.encodeCall(
                    Launchpad.initialize,
                    (
                        owner,
                        address(quoteToken),
                        address(curve),
                        address(launchpadLPVault),
                        abi.encode(200_000_000 ether, 10 ether)
                    )
                )
            })
        );
    }
}
```

1. Copy and paste the code below into `PoCLaunchpad4.t.sol`
    
    Run with the following command: `forge test --match-contract PoCLaunchpad4 --match-test test_submissionValidity -vv` 
    

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {LaunchpadTestBase4} from "./LaunchpadTestBase4.sol";
import {GTELaunchpadV2Pair} from "contracts/launchpad/uniswap/GTELaunchpadV2Pair.sol";

contract PoCLaunchpad4 is LaunchpadTestBase4 {
    /**
     * PoC can utilize the following variables to access the relevant contracts:
     * - factory: ERC1967Factory.sol 
     * - launchpad: Launchpad.sol
     * - distributor: Distributor.sol
     * - curve: SimpleBondingCurve.sol
     * - launchpadLPVault: LaunchpadLPVault.sol
     * - quoteToken: Quote token used in Launchpad system
     * - uniV2Router: Uniswap V2 Router used in Launchpad system
     */
    function test_submissionValidity() external { // #4
        // @audit-info launchToken is created 
        uint256 fee = launchpad.launchFee();
        deal(dev, 30 ether);

        vm.prank(dev);
        token = launchpad.launch{value: fee}("TestToken", "TST", "https://testtoken.com");

        // @audit-info malicious user back runs launchToken creation
        vm.prank(user);
        address pair = v2Factory.createPair(token, address(quoteToken));
    
        // @audit-info since msg.sender != launchpad ->
        //     - since launchpadFeeDistributor is initialized with address(0)
        //     on the new GTELaunchpadV2Pair contract
        //     -> swap fees won't be accrued for Distributor
        address launchpadLp = GTELaunchpadV2Pair(pair).launchpadLp();
        address launchpadFeeDistributor = GTELaunchpadV2Pair(pair).launchpadFeeDistributor();
        assert(launchpadLp == address(0));
        assert(launchpadFeeDistributor == address(0));
    }
}
```

## Impact

Fee collection for `GTELaunchpadV2Pair` can be bypassed, resulting in loss of fees for users

## Recommendation

Apply fee addresses if either `tokenA` or `tokenB` are launch tokens

```solidity
// GTELaunchpadV2PairFactory.sol
import "../interfaces/ILaunchpad.sol"; 

function createPair(address tokenA, address tokenB) external returns (address pair) {
    if (tokenA == tokenB) revert("UniswapV2: IDENTICAL_ADDRESSES");
    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    if (token0 == address(0)) revert("UniswapV2: ZERO_ADDRESS");
    if (getPair[token0][token1] != address(0)) revert("UniswapV2: PAIR_EXISTS"); // single check is sufficient
    bytes memory bytecode = type(GTELaunchpadV2Pair).creationCode;

+   address _launchpadLp;
+   address _launchpadFeeDistributor;
+   if (ILaunchpad(launchpad).launches(token0).active || ILaunchpad(launchpad).launches(token1).active) {
+       (_launchpadLp, _launchpadFeeDistributor) = (launchpadLp, launchpadFeeDistributor);
+   }
-   (address _launchpadLp, address _launchpadFeeDistributor) =
-      msg.sender == launchpad ? (launchpadLp, launchpadFeeDistributor) : (address(0), address(0));

    bytes32 salt = keccak256(abi.encodePacked(token0, token1, _launchpadLp, _launchpadFeeDistributor));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    }
    IUniswapV2Pair(pair).initialize(token0, token1, _launchpadLp, _launchpadFeeDistributor);
    getPair[token0][token1] = pair;
    getPair[token1][token0] = pair; // populate mapping in the reverse direction
    allPairs.push(pair);
    emit PairCreated(token0, token1, pair, allPairs.length);
}
```

## Arithmetic overflows / underflows are not correctly handled in GTELaunchpadV2Pair::_update()

## Vulnerability Detail

```solidity
function _update(
    uint256 balance0,
    uint256 balance1,
    uint112 _reserve0,
    uint112 _reserve1,
    uint112 newLaunchpadFee0,
    uint112 newLaunchpadFee1
) private {
    // SNIP

>   uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
>   uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
        // * never overflows, and + overflow is desired
>       price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
>       price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;

        // SNIP
}
```

`GTELaunchpadV2Pair` is a fork of `UniswapV2Pair` (ref: https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol)

The logic shown above in `GTELaunchpadV2Pair::_update()` expects overflows / underflows.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

// SNIP

contract GTELaunchpadV2Pair is IUniswapV2Pair, IGTELaunchpadV2Pair, UniswapV2ERC20 {
    using SafeMath for uint256;
    
    // SNIP
}
```

`GTELaunchpadV2Pair` is set to solidity pragma version `0.8.27`, which will cause arithmetic operations to revert on overflow / underflow instead of wrap around by default. 

The `GTELaunchpadV2Pair` contract may eventually experience unexpected DoS in the future when limits are reached. 

## PoC

1. Copy and paste the code below into `LaunchpadTestBase3.sol`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Distributor} from "contracts/launchpad/Distributor.sol";
import {Launchpad} from "contracts/launchpad/Launchpad.sol";
import {ILaunchpad} from "contracts/launchpad/interfaces/ILaunchpad.sol";
import {SimpleBondingCurve} from "contracts/launchpad/BondingCurves/SimpleBondingCurve.sol";
import {IBondingCurveMinimal} from "contracts/launchpad/BondingCurves/IBondingCurveMinimal.sol";
import {LaunchToken} from "contracts/launchpad/LaunchToken.sol";
import {LaunchpadLPVault} from "contracts/launchpad/LaunchpadLPVault.sol";
import {IDistributor} from "contracts/launchpad/interfaces/IDistributor.sol";

import {ERC1967Factory} from "@solady/utils/ERC1967Factory.sol";

import {ERC20Harness} from "../harnesses/ERC20Harness.sol";

import {MockUniV2Router} from "../mocks/MockUniV2Router.sol";

import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {ICLOBManager} from "contracts/clob/ICLOBManager.sol";
import {IOperatorPanel} from "contracts/utils/interfaces/IOperatorPanel.sol";

import {UniV2Bytecode} from "../launchpad/integration/UniV2Bytecode.t.sol";

import {GTELaunchpadV2PairFactory} from "contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol";

import "forge-std/Test.sol";

// Implements the LaunchpadTest setup
contract LaunchpadTestBase3 is Test {
    using FixedPointMathLib for uint256;

    ERC1967Factory factory;
    Launchpad launchpad;
    address distributor;
    IBondingCurveMinimal curve;
    LaunchpadLPVault launchpadLPVault;

    ERC20Harness quoteToken;
    MockUniV2Router uniV2Router;

    address owner = makeAddr("owner");
    address user = makeAddr("user");
    address dev = makeAddr("dev");

    uint256 constant MIN_BASE_AMOUNT = 100_000_000;

    address token; // @audit-info launchToken

    uint256 BONDING_SUPPLY;
    uint256 TOTAL_SUPPLY;

    GTELaunchpadV2PairFactory v2Factory; // @audit-info factory used for PoC #3
    address pair;

    function setUp() public virtual {
        quoteToken = new ERC20Harness("Quote", "QTE");
        
        factory = new ERC1967Factory();

        address uniV2Factory = makeAddr("factory"); // @audit-info mock factory
        vm.etch(uniV2Factory, UniV2Bytecode.UNIV2_FACTORY);
        uniV2Router = new MockUniV2Router(makeAddr("factory"));

        bytes32 launchpadSalt = bytes32(abi.encode("GTE.V1.TESTNET.LAUNCHPAD", owner));

        launchpad = Launchpad(factory.predictDeterministicAddress(launchpadSalt));

        address c_logic = address(new SimpleBondingCurve(address(launchpad)));
        address v_logic = address(new LaunchpadLPVault());

        curve = SimpleBondingCurve(factory.deploy(address(c_logic), owner));
        launchpadLPVault = LaunchpadLPVault(factory.deploy(address(v_logic), owner));
 
        address clobManager = makeAddr("clob manager");
        address operatorAddr = makeAddr("operator");
        vm.mockCall(
            operatorAddr,
            abi.encodeWithSelector(IOperatorPanel.getOperatorRoleApprovals.selector, user, address(0)),
            abi.encode(0)
        );

        distributor = address(new Distributor());
        Distributor(distributor).initialize(address(launchpad));

        address l_logic =
            address(new Launchpad(address(uniV2Router), address(0), clobManager, operatorAddr, distributor));

        vm.prank(owner);
        Launchpad(
            factory.deployDeterministicAndCall({
                implementation: l_logic,
                admin: owner,
                salt: launchpadSalt,
                data: abi.encodeCall(
                    Launchpad.initialize,
                    (
                        owner,
                        address(quoteToken),
                        address(curve),
                        address(launchpadLPVault),
                        abi.encode(200_000_000 ether, 10 ether)
                    )
                )
            })
        );

        token = _launchToken();

        // @audit-info adapted from LaunchpadFeePair.t.sol - deploy GTELaunchpadV2PairFactory
        v2Factory = new GTELaunchpadV2PairFactory(address(this), address(launchpad), address(launchpad), address(distributor));

        // @audit-info create pair
        pair = v2Factory.createPair(token, address(quoteToken));

        BONDING_SUPPLY = curve.bondingSupply(token);
        TOTAL_SUPPLY = curve.totalSupply(token);

        vm.startPrank(user);
        quoteToken.approve(address(launchpad), type(uint256).max);
        ERC20Harness(token).approve(address(launchpad), type(uint256).max);
        vm.stopPrank();
    }

    function _launchToken() internal returns (address) {
        uint256 fee = launchpad.launchFee();
        deal(dev, 30 ether);

        vm.prank(dev);
        return launchpad.launch{value: fee}("TestToken", "TST", "https://testtoken.com");
    }
}
```

1. Copy and paste the code below into `PoCLaunchpad3.t.sol`
    
    Run with the following command: `forge test --match-contract PoCLaunchpad3 --match-test test_submissionValidity -vv`
    

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {LaunchpadTestBase3} from "./LaunchpadTestBase3.sol";

import {GTELaunchpadV2Pair} from "contracts/launchpad/uniswap/GTELaunchpadV2Pair.sol";

contract PoCLaunchpad3 is LaunchpadTestBase3 {
    /**
     * PoC can utilize the following variables to access the relevant contracts:
     * - factory: ERC1967Factory.sol 
     * - launchpad: Launchpad.sol
     * - distributor: Distributor.sol
     * - curve: SimpleBondingCurve.sol
     * - launchpadLPVault: LaunchpadLPVault.sol
     * - quoteToken: Quote token used in Launchpad system
     * - uniV2Router: Uniswap V2 Router used in Launchpad system
     */
    function test_submissionValidity() external { // #3
        uint256 amountIn = 5 ether;

        // @audit-info seed pair contract with funds + initial mint
        deal(token, pair, 100 ether); // @audit-info launchToken = base
        deal(address(quoteToken), pair, 100 ether);
        GTELaunchpadV2Pair(pair).mint(address(launchpad));

        // @audit-info elapse time to type(uint32).max - 34234
        vm.warp(block.timestamp + 2**32 - 34234);
        GTELaunchpadV2Pair(pair).sync();

        // @audit-info elapse enough time to ensure underflow
        vm.warp(block.timestamp + 78434);

        vm.expectRevert();
        GTELaunchpadV2Pair(pair).sync();
    }
}
```

```solidity
    ├─ [6558] GTELaunchpadV2Pair::sync()
    │   ├─ [559] ERC20Harness::balanceOf(GTELaunchpadV2Pair: [0xda8E2E24696542B682CE8396943E1A2546b525Ed]) [staticcall]
    │   │   └─ ← [Return] 100000000000000000000 [1e20]
    │   ├─ [652] LaunchToken::balanceOf(GTELaunchpadV2Pair: [0xda8E2E24696542B682CE8396943E1A2546b525Ed]) [staticcall]
    │   │   └─ ← [Return] 100000000000000000000 [1e20]
    │   └─ ← [Revert] panic: arithmetic underflow or overflow (0x11)
    └─ ← [Stop] 

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 10.43ms (1.34ms CPU time)

Ran 1 test suite in 172.69ms (10.43ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

## Impact

The expected behavior is underflow and overflow, respectively.

However, `_update()` will DoS instead and the `GTELaunchpadV2Pair` contract will be bricked.

## Recommendation

```solidity
function _update(
    uint256 balance0,
    uint256 balance1,
    uint112 _reserve0,
    uint112 _reserve1,
    uint112 newLaunchpadFee0,
    uint112 newLaunchpadFee1
) private {
    // SNIP

    uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
-   uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
+   unchecked { uint32 timeElapsed = blockTimestamp - blockTimestampLast; } // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
        // * never overflows, and + overflow is desired
-       price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
-       price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;

+       unchecked {
+           price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
+           price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
+       }

        // SNIP
}
```

# Jigsaw Finance

## Findings Summary

| ID | Title | Duplicates | 
| - | - | - |
| [H-01](#paramsbalancebefore-is-never-set-which-results-in-more-fees-being-taken-from-the-user-on-withdrawal) | params.balanceBefore is never set which results in more fees being taken from the user on withdrawal | 41 |


## params.balanceBefore is never set which results in more fees being taken from the user on withdrawal

## Summary

In `ElixirStrategy::withdraw()`, `params.balanceBefore` is not cached, which results in incorrect calculations involving the `performanceFee`.

## Vulnerability Detail

```solidity
function withdraw(
    uint256 _shares,
    address _recipient,
    address _asset,
    bytes calldata _data
) external override nonReentrant onlyStrategyManager returns (uint256, uint256, int256, uint256) {
    require(_asset == tokenIn, "3001");

    WithdrawParams memory params = WithdrawParams({
        shares: _shares,
        totalShares: recipients[_recipient].totalShares,
        shareRatio: 0,   // @audit-ok
        shareDecimals: sharesDecimals,
        investment: 0,   // @audit-ok
        assetsToWithdraw: 0,  // @audit not set    
        balanceBefore: 0,     // @audit not set
        withdrawnAmount: 0,   // @audit-ok
        yield: 0,   // @audit-ok
        fee: 0   // @audit-ok
    });

    params.shareRatio = OperationsLib.getRatio({
        numerator: params.shares,
        denominator: params.totalShares,
        precision: params.shareDecimals,
        rounding: OperationsLib.Rounding.Floor
    });  

    _burn({
        _receiptToken: receiptToken,
        _recipient: _recipient,
        _shares: params.shares,
        _totalShares: params.totalShares,
        _tokenDecimals: params.shareDecimals
    });

    params.investment = (recipients[_recipient].investedAmount * params.shareRatio) / 10 ** params.shareDecimals;  
    uint256 deUsdBalanceBefore = IERC20(deUSD).balanceOf(address(this));

    _genericCall({
        _holding: _recipient,
        _contract: tokenOut,
        _call: abi.encodeCall(ISdeUsdMin.unstake, (address(this)))
    });  

    uint256 deUsdAmount = IERC20(deUSD).balanceOf(address(this)) - deUsdBalanceBefore;

    // Swap deUSD to USDT on Uniswap
    _swapExactInputMultihop({
        _tokenIn: deUSD,
        _amountIn: deUsdAmount,
        _recipient: _recipient,
        _swapData: _data,
        _swapDirection: SwapDirection.ToTokenIn
    });  

    // Take protocol's fee from generated yield if any.
>   params.withdrawnAmount = IERC20(tokenIn).balanceOf(_recipient) - params.balanceBefore; 
>   params.yield = params.withdrawnAmount.toInt256() - params.investment.toInt256();

>   // Take protocol's fee from generated yield if any.
>   if (params.yield > 0) {
>       params.fee = _takePerformanceFee({ _token: tokenIn, _recipient: _recipient, _yield: uint256(params.yield) });
>       if (params.fee > 0) {
>           params.withdrawnAmount -= params.fee;
>           params.yield -= params.fee.toInt256();
>       }
>   }  
        
    // SNIP
}
```

In `ElixirStrategy::withdraw()`, `params.balanceBefore` is never cached prior to the swap call - `params.balanceBefore` will be 0 in the subsequent calculation.

After the swap returns, `params.withdrawnAmount` will be calculated as `IERC20(tokenIn).balanceOf(holding) - 0` 

`params.withdrawnAmount` is then used to calculated `params.yield`, which will be an inflated value because the entire `Holding` balance is being used for `params.withdrawnAmount` instead of the withdrawn difference.

This will result in an inflated fee being taken from user in `_takePerformanceFee()`

### PoC

Set up: Copy and paste the test case below into `ElixirStrategy_fork.t.sol`

Run with the following command:  `forge test --match-test test_elixir_inflatedFee --via-ir -vvvv`

```solidity
function test_elixir_inflatedFee() public notOwnerNotZero(user) {
    // @audit-info user deposits 100K USDT and borrows
    uint256 amount = 100_000_000_000; 
    address userHolding = initiateUser(user, tokenIn, amount);

    uint256 investAmount = amount * 10 / 100;
    bytes memory data = abi.encode(
        investAmount * DECIMAL_DIFF, // amountOutMinimum 
        uint256(block.timestamp), // deadline
        abi.encodePacked(tokenIn, poolFee, USDC, poolFee, deUSD)
    );

    // @audit-info user invests 10% of original amount into strategy (10K USDT)
    vm.prank(user, user);
    (uint256 receiptTokens, uint256 tokenInAmount) =
        strategyManager.invest(tokenIn, address(strategy), investAmount, 0, data);

    // @audit-info user has 90K USDT in Holding
    uint256 tokenInBalanceBefore = IERC20(tokenIn).balanceOf(userHolding);
    assert(tokenInBalanceBefore == (amount - investAmount));

    skip(90 days);

    // @audit-info cooldown shares for withdrawal
    (uint256 investedAmount1, uint256 totalShares) = strategy.recipients(userHolding);
    vm.prank(user, user);
    strategy.cooldown(userHolding, totalShares);
    skip(7 days);

    uint256 feeAddrBeforeBalance = IERC20(tokenIn).balanceOf(manager.feeAddress());

    // @audit-info user claims all shares
    bytes memory dataClaimInvest = abi.encode(
        investAmount, // amountOutMinimum
        uint256(block.timestamp), // deadline
        abi.encodePacked(deUSD, poolFee, USDC, poolFee, tokenIn)
    );

    vm.prank(user, user);
    (uint256 withdrawnAmount, uint256 initialInvestment, int256 yield, uint256 fee) = strategyManager.claimInvestment({
        _holding: userHolding,
        _token: tokenIn,
        _strategy: address(strategy),
        _shares: totalShares,
        _data: dataClaimInvest
    });
  
    // @audit-info withdrawnAmount, yield, and fee 
    // are all greater than initialInvestment
    assert(withdrawnAmount > initialInvestment);
    assert(uint256(yield) > initialInvestment);
    assert(fee > initialInvestment);

    // @audit-info correct yield + fee calculation
    // since withdrawnAmount = investment -> yield should be 0
    uint256 shareRatio = OperationsLib.getRatio({
        numerator: totalShares,
        denominator: totalShares,
        precision: strategy.sharesDecimals(),
        rounding: OperationsLib.Rounding.Floor
    });
    uint256 investment = investedAmount1 * shareRatio / (10 ** strategy.sharesDecimals());
    uint256 calculatedYield = investAmount - investment;
    assert(calculatedYield == 0);

    // @audit-info since yield is 0, fee should also be 0
    uint256 correctFee = OperationsLib.getFeeAbsolute(
        calculatedYield,
        strategy.feeManager().getHoldingFee({
            _holding: userHolding,
            _strategy: address(strategy)
        })
    );
    assert(correctFee == 0);
    assert(fee != 0);
}
```

```solidity
    │   ├─ emit StrategyClaim(holding: 0x898b3A32498692B05C343FA65c3f31a12A63d96C, user: VM: [0x7109709ECfa91a80626fF3989D68f67F5b1DD12D], token: 0xdAC17F958D2ee523a2206206994597C13D831ec7, strategy: ERC1967Proxy: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], shares: 9583328004213276200274 [9.583e21], withdrawnAmount: 86501963114 [8.65e10], initialInvestment: 10000000000 [1e10], yield: 76501963114 [7.65e10], fee: 13500346433 [1.35e10])
    │   └─ ← [Return] 86501963114 [8.65e10], 10000000000 [1e10], 76501963114 [7.65e10], 13500346433 [1.35e10]
    ├─ [633] ERC1967Proxy::fallback() [staticcall]
    │   ├─ [326] ElixirStrategy::sharesDecimals() [delegatecall]
    │   │   └─ ← [Return] 18
    │   └─ ← [Return] 18
    ├─ [633] ERC1967Proxy::fallback() [staticcall]
    │   ├─ [326] ElixirStrategy::sharesDecimals() [delegatecall]
    │   │   └─ ← [Return] 18
    │   └─ ← [Return] 18
    ├─ [1163] ERC1967Proxy::fallback() [staticcall]
    │   ├─ [856] ElixirStrategy::feeManager() [delegatecall]
    │   │   └─ ← [Return] FeeManager: [0x66930f2122C5f09112b4237C49EfDF03E227487C]
    │   └─ ← [Return] FeeManager: [0x66930f2122C5f09112b4237C49EfDF03E227487C]
    ├─ [3054] FeeManager::getHoldingFee(0x898b3A32498692B05C343FA65c3f31a12A63d96C, ERC1967Proxy: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a]) [staticcall]
    │   ├─ [424] Manager::strategyManager() [staticcall]
    │   │   └─ ← [Return] StrategyManager: [0x2D3969801b34419316b25d588f86767C7bEC7374]
    │   ├─ [921] StrategyManager::strategyInfo(ERC1967Proxy: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a]) [staticcall]
    │   │   └─ ← [Return] 1500, true, true
    │   └─ ← [Return] 1500
    └─ ← [Return] 

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 8.05s (4.67s CPU time)

Ran 1 test suite in 8.41s (8.05s CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

## Impact

Inflated fee is taken from the user

## Recommendation

```solidity
function withdraw(
    uint256 _shares,
    address _recipient,
    address _asset,
    bytes calldata _data
) external override nonReentrant onlyStrategyManager returns (uint256, uint256, int256, uint256) {
    // SNIP

    _genericCall({
        _holding: _recipient,
        _contract: tokenOut,
        _call: abi.encodeCall(ISdeUsdMin.unstake, (address(this)))
    }); 

    uint256 deUsdAmount = IERC20(deUSD).balanceOf(address(this)) - deUsdBalanceBefore;
+   params.balanceBefore = IERC20(tokenIn).balanceOf(_recipient);

    // Swap deUSD to USDT on Uniswap
    _swapExactInputMultihop({
        _tokenIn: deUSD,
        _amountIn: deUsdAmount,
        _recipient: _recipient,
        _swapData: _data,
        _swapDirection: SwapDirection.ToTokenIn
    }); 

    // Take protocol's fee from generated yield if any.
    params.withdrawnAmount = IERC20(tokenIn).balanceOf(_recipient) - params.balanceBefore;  
    params.yield = params.withdrawnAmount.toInt256() - params.investment.toInt256();
        
    // SNIP
}
```

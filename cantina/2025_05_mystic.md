## stPlumeMinter::stakeWithheld() is bricked

## Summary

`stPlumeMinter::stakeWithheld()` is bricked because `depositEther()` is called twice.

The second time `depositEther()` is called - the contract won’t have any balance and revert.

## Vulnerability Detail

```solidity
function stakeWitheld(uint16 validatorId, uint256 amount) external nonReentrant onlyRole(REBALANCER_ROLE) returns (uint256 amountRestaked) {
    _rebalance();
    currentWithheldETH -= amount;
    depositEther(amount);
        
    emit ETHSubmitted(address(this), address(this), amount, 0);
    return amount;
}
    
function _rebalance() internal {
    uint256 amount = _claim();
    frxETHToken.minter_mint(address(this), amount);
    frxETHToken.transfer(address(sfrxETHToken), amount);
    depositEther(address(this).balance);
}

// stakeWitheld() flattened
function stakeWitheld(uint16 validatorId, uint256 amount) external nonReentrant onlyRole(REBALANCER_ROLE) returns (uint256 amountRestaked) {
    // _rebalance()
    uint256 amount = _claim();
    frxETHToken.minter_mint(address(this), amount);
    frxETHToken.transfer(address(sfrxETHToken), amount);
>   depositEther(address(this).balance);
        
    currentWithheldETH -= amount;
>   depositEther(amount);
        
    emit ETHSubmitted(address(this), address(this), amount, 0);
    return amount;
}
```

In `stPlumeMinter::stakeWitheld()` flow, `_rebalance()` is called first.

At the end of `_rebalance()`, the entire balance is deposited.

When `_rebalance()` returns, `depositEther()` is called again, but at this time, the contract does not have any funds left.

```solidity
function depositEther(uint256 _amount) internal returns (uint256 depositedAmount) {
    // SNIP
    
    while (remainingAmount > 0) {
        uint256 depositSize = remainingAmount;
        (uint256 validatorId, uint256 capacity) = getNextValidator(remainingAmount);

        if(capacity < depositSize) {
            depositSize = capacity;
        }
            
 >      plumeStaking.stake{value: depositSize}(uint16(validatorId));
        remainingAmount -= depositSize;
        depositedAmount += depositSize;
            
        emit DepositSent(uint16(validatorId));
    }
        
    return depositedAmount;
}
```

The function will revert due to no funds when `stake()` is called to the staking contract in `depositEther()`.

This will result in `stakeWitheld()` being DoSed and unusable most of the time.

Copy and paste the test case below into `stPlumeMinter.t.sol`

❯ `forge test --fork-url [https://rpc.plume.org](https://rpc.plume.org/) --match-test test_stakeWitheldDoS -vv`

```solidity
function test_stakeWitheldDoS() public {
    vm.startPrank(owner);
    // Set withhold ratio to 50% (500000 = 50%)
    minter.setWithholdRatio(500000);
    vm.stopPrank();
        
    // Submit ETH with 50% to be withheld
    vm.prank(user1);
    minter.submit{value: 10 ether}();
        
    // Check that ETH was withheld
    assertEq(minter.currentWithheldETH(), 5 ether);
        
    // Submit ETH first
    vm.prank(user1);
    minter.submitAndDeposit{value: 5 ether}(user2);
        
    // Add some rewards to the contract
    vm.deal(address(mockPlumeStaking), address(mockPlumeStaking).balance + 1 ether);
        
    // Rebalance as owner
    vm.prank(owner);
    //vm.expectRevert();   // @audit-info reverts due to OutOfFunds error
    minter.stakeWitheld(1, 1 ether);
}
```

```solidity
    │   ├─ [0] 0xA20bfe49969D4a0E9abfdb6a46FeD777304ba07f::stake{value: 1000000000000000000}(1)
    │   │   └─ ← [OutOfFunds] EvmError: OutOfFunds
    │   └─ ← [Revert] EvmError: Revert
    └─ ← [Revert] EvmError: Revert

Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 9.13s (6.68s CPU time)

Ran 1 test suite in 10.34s (9.13s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)

Failing tests:
Encountered 1 failing test in test/fork/stPlumeMinter.t.sol:StPlumeMinterForkTest
[FAIL: EvmError: Revert] test_stakeWitheldDoS() (gas: 873571)

Encountered a total of 1 failing tests, 0 tests succeeded
```

## Impact

`stPlumeMinter::stakeWitheld()` is bricked

## Recommendation

Re-work `stPlumeMinter::_rebalance()` so that the `depositEther()` call accounts for `currentWitheldETH`

## stPlumeMinter::unstake() looping logic is flawed

## Summary

The looping logic in `unstake()` is flawed and may cause unnecessary reverts and may prevent users from unstaking.

## Vulnerability Detail

```solidity
function unstake(uint256 amount) external nonReentrant returns (uint256 amountUnstaked) {
    // SNIP
    }else{
        uint256 remainingToUnstake = amount;
        amountUnstaked = 0;
        if (currentWithheldETH > 0) {  
            amountUnstaked = currentWithheldETH;
            remainingToUnstake -= currentWithheldETH;  
            currentWithheldETH = 0;
        }  

>       uint16 validatorId = 1;
        uint numVals = numValidators();
>       while (remainingToUnstake > 0 && validatorId <= numVals) { 
            (bool active, ,uint256 stakedAmount,) = plumeStaking.getValidatorStats(uint16(validatorId));
                
            if (active && stakedAmount > 0) {
                // Calculate how much to unstake from this validator
                uint256 unstakeFromValidator = remainingToUnstake > stakedAmount ? stakedAmount : remainingToUnstake;
                uint256 actualUnstaked = plumeStaking.unstake(validatorId, unstakeFromValidator);
                amountUnstaked += actualUnstaked;
                remainingToUnstake -= actualUnstaked;
                if (remainingToUnstake == 0) break;
            }
>           validatorId++;
>           require(validatorId <= 10, "Too many validators checked");
        }
        cooldownTimestamp = plumeStaking.cooldownEndDate();
    }
    require(amountUnstaked > 0, "No funds were unstaked");
    require(amountUnstaked >= amount, "Not enough funds unstaked");
    withdrawalRequests[msg.sender] = WithdrawalRequest({
        amount: amountUnstaked,
        timestamp: cooldownTimestamp
    });
        
    emit Unstaked(msg.sender, amountUnstaked);
    return amountUnstaked;
}
```

In `stPlumeMinter::unstake()`, when the `currentWithheldETH` is not enough to cover the user unstake amount, the validators are iterated and withdrawn from to cover the remaining unstake amount.

`validatorId` is initialized with 1 and increments by 1, up to 10 max.

 This index value is used to fetch the validator stats - This is incorrect as the `validator[]` whitelist should be iterated over for the real validatorId’s and not the index)

This will result in `unstake()` reverting due to various reasons:

- If the `validatorId` does not exist
- or, if the `amountUnstaked ≤ amount`
- or, if `amountUnstaked == 0`

This bug will be triggered anytime a user unstakes more than what is deposited in `validatorId` = 1.

PoC

Copy and paste the test case below into `stPlumeMinter.t.sol`

❯ `forge test --fork-url [https://rpc.plume.org](https://rpc.plume.org/) --match-test test_unstake_flow2 -vv`

```solidity
function test_unstake_flow2() public {
    vm.startPrank(owner);
    minter.clearValidatorArray();
    minter.addValidator(OperatorRegistry.Validator(1));
    minter.addValidator(OperatorRegistry.Validator(3));
    vm.stopPrank();

    // First submit ETH
    vm.deal(user1, 100 ether);
    vm.prank(user1);
    minter.submit{value: 100 ether}();

    // @audit-info simulating amountUnstaked > amountStaked
    // so that loop will iterate and not exit early
    deal(address(frxETHToken), user2, 200 ether);
    vm.startPrank(user2);
    frxETHToken.approve(address(minter), 120 ether);
    minter.unstake(120 ether);
}
```

```solidity
    │   ├─ [3532] 0xA20bfe49969D4a0E9abfdb6a46FeD777304ba07f::getValidatorStats(2) [staticcall]
    │   │   ├─ [2647] 0xb4791ac282E9eA7b9f76444D9b5B34c7892f07Df::getValidatorStats(2) [delegatecall]
    │   │   │   └─ ← [Revert] custom error 0xd53c2825: 
    │   │   └─ ← [Revert] custom error 0xd53c2825: 
    │   └─ ← [Revert] custom error 0xd53c2825: 
    └─ ← [Revert] custom error 0xd53c2825: 

Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 14.15s (11.28s CPU time)

Ran 1 test suite in 15.98s (14.15s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)

Failing tests:
Encountered 1 failing test in test/fork/stPlumeMinter.t.sol:StPlumeMinterForkTest
[FAIL: custom error 0xd53c2825: ] test_unstake_flow2() (gas: 1161776)

Encountered a total of 1 failing tests, 0 tests succeeded
```

## Impact

Unintended DoS of `unstake()` and stuck user funds 

## Recommendation

```solidity
function unstake(uint256 amount) external nonReentrant returns (uint256 amountUnstaked) {
    // SNIP
    }else{
        uint256 remainingToUnstake = amount;
        amountUnstaked = 0;
        if (currentWithheldETH > 0) {  
            amountUnstaked = currentWithheldETH;
            remainingToUnstake -= currentWithheldETH;  
            currentWithheldETH = 0;
        }  

        uint16 validatorId = 1;
        uint numVals = numValidators();
        while (remainingToUnstake > 0 && validatorId <= numVals) { 
+           uint256 valId = validators[validatorId].validatorId;
-           (bool active, ,uint256 stakedAmount,) = plumeStaking.getValidatorStats(uint16(validatorId));
+           (bool active, ,uint256 stakedAmount,) = plumeStaking.getValidatorStats(valId);

                
            if (active && stakedAmount > 0) {
                // Calculate how much to unstake from this validator
                uint256 unstakeFromValidator = remainingToUnstake > stakedAmount ? stakedAmount : remainingToUnstake;
-               uint256 actualUnstaked = plumeStaking.unstake(validatorId, unstakeFromValidator);
+               uint256 actualUnstaked = plumeStaking.unstake(valId, unstakeFromValidator);
                amountUnstaked += actualUnstaked;
                remainingToUnstake -= actualUnstaked;
                if (remainingToUnstake == 0) break;
            }
            validatorId++;
            require(validatorId <= 10, "Too many validators checked");
        }
        cooldownTimestamp = plumeStaking.cooldownEndDate();
    }
    require(amountUnstaked > 0, "No funds were unstaked");
    require(amountUnstaked >= amount, "Not enough funds unstaked");
    withdrawalRequests[msg.sender] = WithdrawalRequest({
        amount: amountUnstaked,
        timestamp: cooldownTimestamp
    });
        
    emit Unstaked(msg.sender, amountUnstaked);
    return amountUnstaked;
}
```

## MorphoLeverageBundler::getMarketPairKey() slippage check is ineffective

## Summary

`MorphoLeverageBundler::getMarketPairKey()` uses the same price for both borrow and collateral tokens, which will cause the slippage check to be ineffective.

## Vulnerability Detail

```solidity
function getMarketPairKey(MarketParams calldata marketParams) public view returns (bytes32) {
    address borrowToken = marketParams.loanToken;
    address collateralToken = marketParams.collateralToken;
    uint256 borrowPrice = IOracle(marketParams.oracle).price();   // @audit the same price is fetched for both borrow and collateral ?
    uint256 collateralPrice = IOracle(marketParams.oracle).price();
    uint256 ratio = (collateralPrice * SLIPPAGE_SCALE) / borrowPrice;
    require(ratio <= SLIPPAGE_SCALE + 500 && ratio >= SLIPPAGE_SCALE - 500, "Price deviation too high for safe leverage"); // 5% deviation allowed
    return keccak256(abi.encodePacked(borrowToken, collateralToken, ratio));
}
```

`MorphoLeverageBundler::getMarketPairKey()` fetches the same price for both borrow and collateral price.

As a result,`ratio` will always be equal to `SLIPPAGE_SCALE` and the slippage check will always pass.

This will allow users to execute transactions even when it is unsafe to do so because the check will never revert.

PoC

Copy and paste the test case below into `MorphoLeverageBundlerTest.sol`

❯ `forge test --fork-url [https://rpc.plume.org](https://rpc.plume.org/) --match-test testGetMarketPairKey -vv`

```solidity
function testGetMarketPairKey() public {
    // @audit-info validate getMarketPairKey()
    // - 10000 substituted for SLIPPAGE_SCALE
    address borrowToken = testMarketParams.loanToken;
    address collateralToken = testMarketParams.collateralToken;
    uint256 borrowPrice = IOracle(testMarketParams.oracle).price();
    uint256 collateralPrice = IOracle(testMarketParams.oracle).price();
    uint256 ratio = (collateralPrice * 10000) / borrowPrice;
    require(ratio <= 10000 + 500 && ratio >= 10000 - 500, "Price deviation too high for safe leverage");
    bytes32 returnValue = keccak256(abi.encodePacked(borrowToken, collateralToken, ratio));

    // @audit-info borrowPrice = collateralPrice
    assert(borrowPrice == collateralPrice);

    // @audit-info ratio will always be = SLIPPAGE_SCALE and in-range
    assert(ratio == 10000);

    // @audit-info double-check calculations above were correct
    bytes32 getMarketPairKey = leverageBundler.getMarketPairKey(testMarketParams);
    assert(getMarketPairKey == returnValue);
}
```

```solidity
Ran 1 test for test/MorphoLeverageBundlerTest.sol:MorphoLeverageBundlerTest
[PASS] testGetMarketPairKey() (gas: 22102)
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.33s (2.98ms CPU time)

Ran 1 test suite in 12.68s (11.33s CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

## Impact

`MorphoLeverageBundler` may execute calls even when the market conditions are unsafe to do so.

## Recommendation

Re-work `MorphoLeverageBundler::getMarketPairKey()` to use the correct oracle for each token.
